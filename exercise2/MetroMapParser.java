package exercise2;

import java.io.*;
import java.util.*;

/**
* This class reads a text description of a metro subway system
* and generates a graph representation of the metro.
**
**
The grammar for the file is described below in BNF. A typical line
* in the file looks like this :
**
<code> 20 NorthStation Green 19 22 Orange 15 22 </code>
**
where :
* 20 is the StationID
* NorthStation is the StationName
* Green 19 22 is a LineID which:
* Green is the LineName
* 19 is the StationID of the outbound station
* 22 is the StationID of the inbound station
* Orange 15 22 is a LineID in which :
* Orange is the LineName
* 15 is the StationID of the outbound station
* 22 is the StationID of the inbound station
**Therefore, NorthStation has two outgoing lines.
**
note : 0 denotes the end of a line : i.e. in this case,
* OakGrove would be at the end of the line, as there is no other outbound
* station.
* *<p>
* metro-map ::= station-spec* <BR>
* station-spec ::= station-id station-name station-line+ <BR>
* station-id ::= (positive integer) <BR>
* station-name ::= string <BR>
* station-line ::= line-name station-id station-id <BR>
* */

public class MetroMapParser {
	
	private BufferedReader fileInput;
    static LinkedList<Station> Stations=new LinkedList<Station>();
    LinkedList<Line> Lines=new LinkedList<Line>();
    
	
	private static void usage() {
	//prints a usage message to System.out
	     System.out.println("java ex3.MetroMapParser <filename>");
	}
	
	/**
	* @effects: creates a new parser that will read from the file
	* filename unless the file does not exist. The filename should specify
	* the exact location of the file. This means it should be something like
	* /mit/$USER/6.170/ex3/bostonmetro.txt
	***
    @throws java.io.IOException if there filename cannot be read
    **
    @returns a new MetroMapParser that will parse the file filename
    */
	
    public MetroMapParser(String filename) throws IOException {
    //a buffered reader reads line by line, returning null when file is done
          fileInput = new BufferedReader(new FileReader(filename));
    }
    
    /**
    * @effects: parses the file, and generates a graph from it, unless there
    * is a problem reading the file, or there is a problem with the format of the
    * file.
    **
    @throws java.io.IOException if there is a problem reading the file
    * @throws ex3.BadFileException if there is a problem with the format of the
    file
    **
    @returns the Graph generated by the file
    */
    
    public void generateGraphFromFile() throws IOException, BadFileException{
        String line = fileInput.readLine();
        StringTokenizer st = null;
        int stationID;
        String stationName;
        String lineName;
        int outboundID, inboundID;

        
        while(line != null) {
      //STUDENT :
      //
      //in this loop, you must collect the information necessary to
      //construct your graph, and you must construct your graph as well.
      //how and where you do this will depend on the design of your graph.
      //
      //StringTokenizer is a java.util Class that can break a string into tokens
      // based on a specified delimiter. The default delimiter is "\t\n\r\f"
      
      // which corresponds to the space character, the tab character, 
        	//the newline character,
      // the carriage-return character and the form-feed character.
        	
            st = new StringTokenizer(line);
      //We want to handle empty lines effectively, we just ignore them!
            if(!st.hasMoreTokens()) {
                line = fileInput.readLine();
                continue;
            }

            else{
            	stationID=Integer.parseInt(st.nextToken());
                
                
                if(!st.hasMoreTokens()) {
                	
                    throw new BadFileException("no station name");
                }

                stationName = st.nextToken();
                
                Stations.add(new Station(stationID,stationName));
                
                if(!st.hasMoreTokens()) {
                    throw new BadFileException("station is on no lines");
                }
                
                while(st.hasMoreTokens()) {
                    lineName = st.nextToken();
                    
                    if(!st.hasMoreTokens()) {
                        throw new BadFileException("poorly formatted line info");
                    }
                   
                    outboundID = Integer.parseInt(st.nextToken());
                    
                    if(!st.hasMoreTokens()) {
                        throw new BadFileException("poorly formatted adjacent stations");
                    }
                    
                    inboundID = Integer.parseInt(st.nextToken());
                    
                    if(outboundID==0){
                    	Lines.add(new Line(lineName,stationID,inboundID));
                    	Stations.getLast().addAdjacentLines(Lines.getLast());
                    }
                    if(inboundID==0){
                    	Lines.add(new Line(lineName,outboundID,stationID));
                    	Stations.getLast().addAdjacentLines(Lines.getLast());
                    }
                    else{
                    	Lines.add(new Line(lineName,outboundID,stationID));
                    	Stations.getLast().addAdjacentLines(Lines.getLast());
                    	Lines.add(new Line(lineName,stationID,inboundID));
                    	Stations.getLast().addAdjacentLines(Lines.getLast());
                    }
                }//end while, in this convention outbound=first, inbound=second
                
                
                
                line = fileInput.readLine();
                
            }
        }//finish reading and constructing the lines and stations 
        
        
      for(Line l1:Lines){
    	  for(Line l2:Lines){
    		  if(l1.getFirstID()==l2.getSecondID()&&l1.getSecondID()==l2.getFirstID()&&
    			l1.getLineName()==l2.getLineName()){
    			  Lines.remove(l2);
    		  }
    	  }
      }//end for, remove duplicates 
      
      
      for(Line l:Lines){
    	  l.setFirstStation(Stations);
    	  l.setSecondStation(Stations);
      }//2 fors
      

      for(Line l:Lines){
    	  Station s1 = l.getFirstStation();
    	  //System.out.println(s1.getStationName());
    	  s1.addAdjacentLines(l);
    	  //System.out.println("successful");
    	  s1.addAdjacentStations(l.getSecondStation());
    	  Station s2=l.getSecondStation();
    	  s2.addAdjacentLines(l);
    	  s2.addAdjacentStations(l.getFirstStation());
      }//construct the links between lines and stations

    }
    
    
    public static Station searchStation(String name){
    	Station target=null;
    	for(Station s:Stations){
    		if(s.getStationName().equals(name)){
    			target=s;
    		}
    	}
    	return target;
    }//how to handle exceptions? Why static?
    
    
    public static LinkedList<Station> pathStations(Station start, Station end){
    	
    	LinkedList<Station> pathStations=new LinkedList<Station>();
    	Map<Station, Station> previousStationMap=new HashMap<Station, Station>();
    	//the Integer represents the distance from start to the target station
    	for(Station s:Stations){
    		previousStationMap.put(s, null);   			
    	}//Initialization

    	Stack<Station> s1=new Stack<Station>();
    	s1.push(start);
    	while(!s1.isEmpty()){
    		Station u=s1.pop();
    		if(!u.isVisited()){
    			u.setVisited(true);
    			for(Station s:u.getAdjacentStations()){
    				if(!s.isVisited()){
    					s1.push(s);
    					previousStationMap.put(s, u);
    					}//end if2
    			}//end for
    		}//end if1
    	}//end while, the stack s1 is now empty, each station have a previous station except the start	
    	
    	s1.push(end);
    	while(s1.lastElement()!=start){
    		Station v=s1.pop();
    		pathStations.addFirst(v);
    		s1.push(previousStationMap.get(v));
    	}
    	
    	pathStations.addFirst(start);
			
		//i want a depth first search to traverse all nodes of the graph

    	
    	return pathStations;
    }
    

    public void DFS(Station start, LinkedList<Station> Stations){
    	Stack<Station> s1=new Stack<Station>();
    	s1.push(start);
    	while(!s1.isEmpty()){
    		Station u=s1.pop();
    		if(!u.isVisited()){
    			u.setVisited(true);
    			Stations.addLast(u);
    			for(Station s:u.getAdjacentStations()){
    				if(!s.isVisited()){s1.push(s);}
    			}//end for
    		}//end if1
    	}//end while
    }//a depth first search
    
    
	public static void main(String[] args){
		 
		@SuppressWarnings("resource")
		Scanner sc=new Scanner(System.in);
		
		 System.out.println("Please enter the file name");

		 String filename = sc.nextLine();
		 
		 System.out.println("loading the file "+filename+" into the graph");
		   
		 try {
			   
		     MetroMapParser mmp = new MetroMapParser(filename);
		     mmp.generateGraphFromFile();
		     System.out.println("successfully load the information to the graph");
		     
			  
			 System.out.println("Please enter the starting station");
			 String stationName1=sc.next();
	         Station start=searchStation(stationName1);

			 System.out.println("Please enter the final station");
			 String stationName2=sc.next();
	         Station end=searchStation(stationName2);
	          
			 LinkedList<Station> path=pathStations(start, end);
			 for(Station s:path){
				 System.out.println(s.getStationName()+"\n");
			 }
		 }
		 catch(Exception e) {
		     e.printStackTrace();
		 }

	}
	
}
       

